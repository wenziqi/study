2020.11.04
1.优化一个被频繁调用的接口。该接口返回一个列表，由于业务复杂，再加上原来负责的人没有设计好，消耗比较大，并且玩家登陆时会被调用n多次。优化方法是：不改变原来的处理流程，将其返回的结果缓存，两秒后再重新计算结果。

2.优化字符串分割方法split。项目中是用了string.gmatch函数.优化方案：1）正则表达式字符串存到一个变量，避免lua频繁生成一个字符串对象，降低内存和cpu消耗；
2）将分割后的字符串数字缓存起来，分割时检测到缓存池有该数组，则直接返回缓存池中的数组。_c=｛key=array｝
再做缓存池的优化过程中，碰到了一个问题：索引为nil值，报错了，而没有缓存方案时运行正常。检查了自己修改的代码，没有问题。再仔细分析lua栈，发现从缓存中获取出来的数组变空了。再仔细阅读其他接口，发现调用了table.remove接口，将数组的最后一个元素删掉了，导致下次分割时获得的结果不对。修改相应函数，不对数组做删除处理。

3.公司有个项目准备上线测试，运营方提出一个需求：玩家充值后获得的一级货币由运营方平台托管处理，游戏中消耗货币时需要向平台查询然后再扣钻。这里就涉及到异步、阻塞、并发等情况了。技术大佬再群里问有什么好的解决方案。看来这公司也没有相关方面的经验，同事们在群里激烈讨论，提出的方案大概是：
1）对货币加锁，但是游戏实现起来就比较繁琐
2）游戏保存一份数据，登陆或定时同步数据给平台，但这就违背了平台的意愿了，平台的目的就是要平台托管数据才提出这种足球的
这种需求我在上家公司就碰到了。有用加锁的方案，暗示问题也比较多，踩了不少的坑，尤其是网络不好的情况，加锁、解锁、扣款，再加上项目业务逻辑复杂，玩家还可能同时在不同的项目或者服务器中同时消费，导致各种问题。后来再和其他平台合作时，我们就设计了另一套方案，不在对货币直接加锁，而是改成冻结，每次消费扣币时先请求冻结，平台检测如果有足够货币则冻结，每次冻结生成一个唯一标识，并放到保存队列，同时先行扣掉对应货币。这一过程对玩家是透明的，玩家感觉不到。如果冻结成功并且游戏成功发放道具，则通知平台，平台删除冻结记录，达到真正扣币的目的。如果失败，平台则解冻，并返还响应的货币。